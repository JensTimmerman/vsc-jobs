#!/usr/bin/python

import getopt, sys, re
from PBSQuery import PBSQuery

try:
    opts, args = getopt.getopt(sys.argv[1:], "doxfuiIRanbemr:")
except getopt.GetoptError, err:
    print err
    sys.exit(1)

states = ["down", "offline", "free", "job-exclusive", "state-unknown", "idle", "bad", "error",
          "Busy"] #states from moab
state = []
nagios = False
regex = None
filteridle = False
singlenodeinformation = False
reportsinglenodeinformation=False
p = PBSQuery()

for o, a in opts:
    if o == "-n":
        nagios = True
    elif o == "-r":
        regex = re.compile(r"%s" % a)
    elif o == "-d":
        state.append(states[0])
    elif o == "-o":
        state.append(states[1])
    elif o == "-f":
        state.append(states[2])
    elif o == "-x":
        state.append(states[3])
    elif o == "-u":
        state.append(states[4])
    elif o == "-b":
        state.append(states[6])
    elif o == "-e":
        state.append(states[7])
    elif o == "-i":
        ## these are free nodes that have no jobs
        if not states[2] in states:
            state.append(states[2])
        state.append(states[5])
        filteridle = True
    elif o == "-I":
        ## node information in bash form
        ## report some node info in bash friendly format
        singlenodeinformation = True
    elif o == "-R":
        ## report node information details
        reportsinglenodeinformation = True
    elif o == "-m":
        #use mdiag instead of pbs
        from lxml import etree
        from vsc.utils.run import Command


        class Query(object):
            """
            Implements something similar to PBSQuery
            """

            def __init__(self, state=None):
                """constructor"""
                pass

            def getnodes(self, something=None):
                """Similar to getnodes from PBSQuery
                
                returns a dict of nodes, with a 'status' field which is a dict of statusses
                the something parameter is ignored. (for now)
                """
                xml, err = Command("mdiag -n --format=xml").run()
                if err:
                    print "Error occured running mdiag -n: %s" % err
                #build tree
                tree = etree.fromstring(xml)
                nodes = {}
                for node in tree:
                    nodes[node.get("NODEID")] = {'state': [node.get("NODESTATE").lower()], 'size': node.get("RAMEM")}
                return nodes

        p = Query()


if singlenodeinformation or reportsinglenodeinformation:
    interesni_nodes = ('free', 'job-exclusive',)
    res = {'cores':{}, 'physmem':{}}
    for name,x in p.getnodes().items():
        if not ('status' in x and 'np' in x and 'state' in x): continue
        if not reportsinglenodeinformation and not x['state'][0] in interesni_nodes: continue
        cores = int(x['np'][0])
        rp = x['status'].get('physmem', [''])[0]

        res['cores'].setdefault(cores, [])
        res['cores'][cores].append(name)

        res['physmem'].setdefault(rp, [])
        res['physmem'][rp].append(name)

    ## return most frequent
    if len(res['cores']) > 1  or len(res['physmem']) > 1:
        sys.stderr.write("Not all nodes have same parameters. Using most frequent ones.\n")
        sys.stderr.flush()
    elif len(res['cores']) < 1 or len(res['physmem']) < 1:
        sys.stderr.write("No nodes found. Setting all to 0.\n")
        sys.stderr.flush()

    freq_count, freq_cores = max([(len(j), i) for i, j in res['cores'].items()])
    freq_count, freq_physmem = max([(len(j), i) for i, j in res['physmem'].items()])

    regbyte = re.compile(r"^\s*(?P<value>\d+)(?P<byte>(?:k|m|g)b)\s*$", re.I)
    kb = 1024
    mb = 1024 * 1024
    gb = 1024 * 1024 * 1024
    def str2megabyte(txt):
        ## converts string like 100kb to float value in byte
        exec("p=int(float(%s)/(1024*1024))") % regbyte.sub(r'\g<value>*\g<byte>', txt).lower()
        return p

    ## usage: export `./show_nodes -I` ; env |grep SHOWNODES_

    print "SHOWNODES_PPN=%d\nSHOWNODES_PHYSMEMMB=%s\n" % (freq_cores, str2megabyte(freq_physmem))
    if reportsinglenodeinformation:
        msg='Nodes with parameters that are different from majority\n'
        for cores,nodes in [(c,n) for c,n in res['cores'].items() if c != freq_cores]:
            msg += "  Cores %s nodes %s\n" % (cores, " ".join(nodes))
        for physmem,nodes in [(c,n) for c,n in res['physmem'].items() if c != freq_physmem]:
            msg += "  Physmem %s nodes %s\n" % (physmem, " ".join(nodes))

        print msg
    sys.exit(0)

pp = p.getnodes(['state'])
nodes = pp.keys()
nodes.sort()
if filteridle:
    ## replace free with idle if no jobs
    for n in nodes:
        if (states[2] in pp[n]['state']) and (not 'jobs' in pp[n]):
            pp[n]['state'] = 'idle'

## sanity check
## match array jobs!
jobreg = re.compile(r"\w+/\w+(\.|\w|\[|\])+")
for n in nodes:
    if 'jobs' in pp[n]:
        jobs = [jobreg.search(x.strip()) for x in pp[n]['jobs']]
        try:
            jobs.index(None)
            pp[n]['state'].append('bad')
        except:
            pass

    if 'error' in pp[n]:
        pp[n]['state'].append('error')



ans = []

##
## WARNING first, since that is the one that gives dependency on others
##
nagiosstatesorder = ['WARNING', 'CRITICAL', 'OK']
nagiosstates = {
    'CRITICAL':[0, 4, 6, 7],
    'WARNING':[1],
    'OK':[2, 3, 5, 8]
    }
nagiosexit = {
    'CRITICAL':2,
    'WARNING':1,
    'OK':0
    }

def matchnagiosstate(nodestates, nagstate):
    """
    Find out if a nodestate matches a nagios state
    """
    for stateidx in nagiosstates[nagstate]:
        if states[stateidx] in nodestates:
            return True
    return False

if regex:
    node = None
    for n in nodes:
        if (not node) and regex.search(n):
            node = n
    if not node:
        state = ['regexp_failed']
    else:
        state = pp[node]['state']

    #print "%s %s"%(state,node)

    nagstate = None
    for nstat in nagiosstatesorder:
        if (not nagstate) and matchnagiosstate(state, nstat):
            nagstate = nstat
    if not nagstate:
        nagstate = "CRITICAL"

    if nagios:
        txt = "show_nodes %s - %s" % (nagstate, ",".join(state))
        print txt
        sys.exit(nagiosexit[nagstate])
    else:
        txt = "%s %s" % (nagstate, ",".join(state))
        print txt
else:
    if nagios:
        bad = 'OK'
        ec = 0
        header = 'show_nodes '
        txt = ''
        for s in states:
            reg = re.compile(r"" + s)
            tmp = 0
            for n in nodes:
                if s in pp[n]['state']:
                    tmp += 1
            if s in ('bad',) and tmp > 0:
                bad = 'CRITICAL - %s bad nodes' % tmp
                ec = 2
            txt += "%s=%s " % (s, tmp)
        txt += "total=%s" % (len(nodes))

        print "%s %s | %s" % (header, bad, txt)
        sys.exit(ec)

    else:
        for n in nodes:
            if len(state) == 0:
                ans.append(n)
                continue
            for s in state:
                if s in pp[n]['state']:
                    ans.append(n)
                    break

        print ' '.join(ans)


