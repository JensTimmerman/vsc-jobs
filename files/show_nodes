#!/usr/bin/python

import getopt, sys, re
from PBSQuery import PBSQuery

try:
    opts, args = getopt.getopt(sys.argv[1:], "doxfuianbemr:")
except getopt.GetoptError, err:
    print err
    sys.exit(1)

states = ["down", "offline", "free", "job-exclusive", "state-unknown", "idle", "bad", "error",
          "Busy"] #states from moab
state = []
nagios = False
regex = None
filteridle = False
p = PBSQuery()

for o, a in opts:
    if o == "-n":
        nagios = True
    elif o == "-r":
        regex = re.compile(r"%s" % a)
    elif o == "-d":
        state.append(states[0])
    elif o == "-o":
        state.append(states[1])
    elif o == "-f":
        state.append(states[2])
    elif o == "-x":
        state.append(states[3])
    elif o == "-u":
        state.append(states[4])
    elif o == "-b":
        state.append(states[6])
    elif o == "-e":
        state.append(states[7])
    elif o == "-i":
        ## these are free nodes that have no jobs
        if not states[2] in states:
            state.append(states[2])
        state.append(states[5])
        filteridle = True
    elif o == "-m":
        #use mdiag instead of pbs
        from lxml import etree
        from vsc.utils.run import Command


        class Query(object):
            """
            Implements something similar to PBSQuery
            """

            def __init__(self, state=None):
                """constructor"""
                pass

            def getnodes(self, something=None):
                """Similar to getnodes from PBSQuery
                
                returns a dict of nodes, with a 'status' field which is a dict of statusses
                the something parameter is ignored. (for now)
                """
                xml, err = Command("mdiag -n --format=xml").run()
                if err:
                    print "Error occured running mdiag -n: %s" % err
                #build tree
                tree = etree.fromstring(xml)
                nodes = {}
                for node in tree:
                    nodes[node.get("NODEID")] = {'status': {'state': node.get("NODESTATE").lower(), 'size': node.get("RAMEM")}}
        p = Query()


pp = p.getnodes(['state'])
nodes = pp.keys()
nodes.sort()
if filteridle:
    ## replace free with idle if no jobs
    for n in nodes:
        if (states[2] in pp[n]['state']) and (not 'jobs' in pp[n]):
            pp[n]['state'] = 'idle'

## sanity check
## match array jobs!
jobreg = re.compile(r"\w+/\w+(\.|\w|\[|\])+")
for n in nodes:
    if 'jobs' in pp[n]:
        jobs = [jobreg.search(x.strip()) for x in pp[n]['jobs']]
        try:
            jobs.index(None)
            pp[n]['state'].append('bad')
        except:
            pass

    if 'error' in pp[n]:
        pp[n]['state'].append('error')


ans = []

##
## WARNING first, since that is the one that gives dependency on others
##
nagiosstatesorder = ['WARNING', 'CRITICAL', 'OK']
nagiosstates = {
    'CRITICAL':[0, 4, 6, 7],
    'WARNING':[1],
    'OK':[2, 3, 5, 8]
    }
nagiosexit = {
    'CRITICAL':2,
    'WARNING':1,
    'OK':0
    }

def matchnagiosstate(nodestates, nagstate):
    """
    Find out if a nodestate matches a nagios state
    """
    for stateidx in nagiosstates[nagstate]:
        if states[stateidx] in nodestates:
            return True
    return False

if regex:
    node = None
    for n in nodes:
        if (not node) and regex.search(n):
            node = n
    if not node:
        state = ['regexp_failed']
    else:
        state = pp[node]['state']

    #print "%s %s"%(state,node)

    nagstate = None
    for nstat in nagiosstatesorder:
        if (not nagstate) and matchnagiosstate(state, nstat):
            nagstate = nstat
    if not nagstate:
        nagstate = "CRITICAL"

    if nagios:
        txt = "show_nodes %s - %s" % (nagstate, ",".join(state))
        print txt
        sys.exit(nagiosexit[nagstate])
    else:
        txt = "%s %s" % (nagstate, ",".join(state))
        print txt
else:
    if nagios:
        bad = 'OK'
        ec = 0
        header = 'show_nodes '
        txt = ''
        for s in states:
            reg = re.compile(r"" + s)
            tmp = 0
            for n in nodes:
                if s in pp[n]['state']:
                    tmp += 1
            if s in ('bad',) and tmp > 0:
                bad = 'CRITICAL - %s bad nodes' % tmp
                ec = 2
            txt += "%s=%s " % (s, tmp)
        txt += "total=%s" % (len(nodes))

        print "%s %s | %s" % (header, bad, txt)
        sys.exit(ec)

    else:
        for n in nodes:
            if len(state) == 0:
                ans.append(n)
                continue
            for s in state:
                if s in pp[n]['state']:
                    ans.append(n)
                    break

        print ' '.join(ans)


