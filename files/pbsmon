#!/usr/bin/python
#
# Author: Bas van der Vlies <basv@sara.nl>
# Date  : 17 Aug 2001
# Desc. : This script displays the status of the PBS batch.
#         It display the status of a node. The ideas are
#         based on the awk-script of Willem Vermin
#
# CVS info:
# $Id: pbsmon.py 134 2006-10-10 09:29:08Z bas $
#
# SDW: add cluster node types
#
import sys
import string
import re
from math import ceil
import pbs

regphysmem=re.compile(r"physmem=(\d+)((?:k|m|g)b)",re.I)
regtotmem=re.compile(r"totmem=(\d+)((?:k|m|g)b)",re.I)
regsize=re.compile(r"size=\d+(?:k|m|g)b:(\d+)((?:k|m|g)b)",re.I)
kb=1024
mb=1024*1024
gb=1024*1024*1024

re_host = re.compile(r"(?P<name>\d+)")

pbs_ND_free_and_job = 'partial'

translate_state = {
    pbs.ND_free             : '_',
    pbs.ND_down             : 'X',
    pbs.ND_offline          : '.',
    pbs.ND_reserve          : 'R',
    pbs.ND_job_exclusive    : 'J',
    pbs.ND_job_sharing      : 'S',
    pbs.ND_busy             : '*',
    pbs.ND_state_unknown    : '?',   
    pbs.ND_timeshared       : 'T',
    pbs.ND_cluster          : 'C',
    pbs_ND_free_and_job     : 'j'
}



def display_cluster_status(nl, sl):

  # Thanks to Daniel Olson, we have now code that can handle
  # 2 and 3 digit hostname numbers
  #
  if len(nl) == 1: 
    width = len( nl[0] )
  else:
    width = len( nl[-1] )

  # Determine what format we have to use
  #
  if width == 3:
    step = end = 19
    format = '%3s'
  else:
    step  = end = 25
    format = '%2s'

  start = 0 

  items = len(nl)

  # Sanity check 
  if end > items:
    end = items

  while start < items:

    print ' ',
    for j in range(start,end):
      print format %(nl[j]) ,

    print '\n ',
    for j in range(start,end):
      print format %(sl[j]) ,
   
    print '\n'

    start = end
    end = end + step 

    if end > items:
      end = items
   
  # Now some statistics
  #
  n = 0
  other = 0
  keys_others = [pbs.ND_busy,
                 pbs.ND_reserve,
                 pbs.ND_timeshared,
                 pbs.ND_job_sharing,
                 pbs.ND_state_unknown,
                 pbs.ND_cluster]
  keys_show = [pbs.ND_job_exclusive,
               pbs.ND_offline,
               pbs_ND_free_and_job,
               pbs.ND_down,
               pbs.ND_free]
  for key in keys_show+keys_others:
    value = translate_state[key]
    if key in [pbs.ND_busy,
               pbs.ND_reserve,
               pbs.ND_timeshared,
               pbs.ND_job_sharing,
               pbs.ND_state_unknown,
               pbs.ND_cluster]:
        other += sl.count(value)
    else:
        if key == "job-exclusive":
            print "%3s %-21s : %d\t |" %( value, "full", sl.count(value) ),
        else:
            print "%3s %-21s : %d\t |" %( value, key, sl.count(value) ),
        if n%2:
          print ''
        n = n + 1

  print "%3s %-21s : %d\t |" %( 'o', "other", other ),
   

def display_node_types(types):
  """
  ['48', 340, 340, 2060]
  """
  template="%sppn=%s, physmem=%sGB, swap=%sGB, vmem=%sGB, local disk=%sGB\n"
  txt="\n\nNode type"
  offset=' '
  if len(types) > 1:
    txt+="s:\n"
    offset="  "
  else:
    txt+=":"
  for typ in types:
    cores,phys,swap,disk=typ
    txt+=template%(offset,cores,phys,swap,phys+swap,disk)

  print txt

def main():
  types = []
  state_list = []
  node_list  = []
  node_nr    = 0

  if len(sys.argv) > 1:
    pbs_server = sys.argv[1]
  else:
    pbs_server = pbs.pbs_default()
    if not pbs_server:
      print "No default pbs server, usage: pbsmon [server] "
      sys.exit(1)

  con = pbs.pbs_connect(pbs_server)
  if con < 0:
     errno, text = pbs.error()
     print errno, text
     sys.exit(1)

  # We are only interested in the state and jobs of a node
  #
  attrl = pbs.new_attrl(2);
  attrl[0].name='state'
  attrl[1].name = 'jobs'


  nodes = pbs.pbs_statnode(con, "", attrl, "NULL")

  # Some is het None dan weer NULL, beats me
  #
  for node in nodes:

    # display_node_status(batch_info)
    node_attr = node.attribs


    # A node can have serveral states, huh. We are only
    # interested in first entry.
    #
    temp = string.splitfields(node_attr[0].value, ',')
    state = temp[0]

    # look if on a free node a job is scheduled, then mark it
    # as other state
    #
    if state == pbs.ND_free:
      if len([x for x in node_attr if x.name == 'jobs']):
        state_list.append(translate_state[pbs_ND_free_and_job])
      else:
        state_list.append(translate_state[state])
    else:
      state_list.append(translate_state[state])

    if not state in (pbs.ND_down,pbs.ND_offline):
      cores=node_attr[1].value
      det=' '.join( [x.value for x in node_attr])
      rp=regphysmem.search(det)
      rt=regtotmem.search(det)
      rs=regsize.search(det)
      if rp and rt and rs:
        exec("p=float(rp.group(1))*%s"%rp.group(2).lower())
        exec("t=float(rt.group(1))*%s"%rt.group(2).lower())
        exec("s=float(rs.group(1))*%s"%rs.group(2).lower())
        ## round mem to 1 gb, size to 5gb
        pmem=ceil(10*p/gb)/10
        tmem=ceil(10*t/gb)/10
        swap=tmem-pmem
        dsize=ceil(10*s/(5*gb))/2
        typ=[cores,pmem,swap,dsize]
        if not typ in types:
          types.append(typ)
        
    result = re_host.search(node.name)
    if result:
      node_list.append( result.group('name') )
    else:
      node_nr = node_nr + 1
      node_list.append( str(node_nr) )
      
  display_cluster_status(node_list, state_list)
  display_node_types(types)

main()
