#!/usr/bin/python

import getopt, sys, re

allowedusers=None

try:
    opts, args = getopt.getopt(sys.argv[1:], "dnu:g:")
except getopt.GetoptError, err:
    print err
    sys.exit(2)

nagios=False
detailed=False

for o, a in opts:
    if o == "-n":
        nagios=True
    if o == "-d":
        detailed=True
    if o == "-u":
        ## allow comma separated list of users
        allowedusers=a.split(',')
    if o == "-g":
        ## allow comma separated list of groups
        groups=a.split(',')
        allowedusers=[]
        import grp
        for gr in groups:
            ## get the members
            g=grp.getgrnam(gr)
            if g:
                allowedusers+=g[3]


try:
    from PBSQuery import PBSQuery
    
    p = PBSQuery()
    
    attrl=['job_state','Resource_List','Job_Owner']
    #js=p.getjobs(attrl)
    js=p.getjobs()
except Exception, err:
    if nagios:
        msg="show_jobs CRITICAL %s"%err
    else:
        msg="show_jobs %s"%err
    print msg
    sys.exit(2)


import re

nod_cor=re.compile(r"(?P<nodes>\d+)(:ppn=(?P<cores>\d+))?")
nod_cor2=re.compile(r"(?P<nodes>node\d+).*?")

reg_user=re.compile(r"(\w+)@\S+")

reg_walltime=re.compile(r"((((?P<day>\d+):)?(?P<hour>\d+):)?(?P<min>\d+):)?(?P<sec>\d+)")

res={}

for n,j in js.items():
    if reg_user.search(j['Job_Owner'][0]):
        user=reg_user.search(j['Job_Owner'][0]).group(1)
    else:
        if not nagios:
            print "No user found for jobowner %s"%j['Job_Owner'][0]
        continue

    if allowedusers:
        if not user in allowedusers:
            continue
    
    if not res.has_key(user):
        res[user]=[0,0,0,0,0,0,0,0,0,'']

    ## requested walltime
    totalwallsec=0
    if j.has_key('Resource_List') and j['Resource_List'].has_key('walltime'):
        m=reg_walltime.search(j['Resource_List']['walltime'][0])
        if m:
            totalwallsec+=int(m.group('sec'))
            if m.group('min'):
                totalwallsec+=int(m.group('min'))*60
                if m.group('hour'):
                    totalwallsec+=int(m.group('hour'))*60*60
                    if m.group('day'):
                        totalwallsec+=int(m.group('day'))*60*60*24
        else:
            if not nagios:
                print "Walltime regexp doesn't match"
                print j
    else:
        if not nagios:
            print "Walltime resourcelist missing"
            print j
        
    m=None
    if j.has_key('Resource_List') and j['Resource_List'].has_key('neednodes'):
        m=nod_cor.match(j['Resource_List']['neednodes'][0])
        if not m:
            if nod_cor2.match(j['Resource_List']['neednodes'][0]):
                m=nod_cor.match("1")
    elif j.has_key('Resource_List') and j['Resource_List'].has_key('nodes'):
        m=nod_cor.match(j['Resource_List']['nodes'][0])
        
        
    if m:
        n=int(m.group('nodes'))
        c=1
        if len(m.groups()) > 1 and m.group('cores'):
            c=int(m.group('cores'))
        cn=c*n
    else:
        if not nagios:
            print j
        res[user][8]+=1
        res[user][9]+="%s "%n
        continue
    
    if j['job_state'][0] in  ('R',):
        res[user][0]+=1
        res[user][1]+=n
        res[user][2]+=cn
        res[user][3]+=totalwallsec*cn

    if j['job_state'][0] in ('Q','H',):
        res[user][4]+=1
        res[user][5]+=n
        res[user][6]+=cn
        res[user][7]+=totalwallsec*cn


ans=[0,0,0,0,0,0,0,0,0,'']
for user,tmp in res.items():
    for i in range(len(ans)):
        ans[i]+=tmp[i]


if nagios:
    ## maxchars: total should be 80, - 2*6 + 1 ' ' 
    absmaxchars=200
    maxuserchars=20
    ## sort by queued jobs (index 3)
    uns=[(tmp[3],user) for user,tmp in res.items()]
    uns.sort(reverse=True)
    count=0
    restr=0
    restq=0
    runuser=0
    queueuser=0
    uniqueuser=0
    txt=''
    for q,user in uns:
        if res[user][0] > 0:
            runuser+=1
        if res[user][4] > 0:
            queueuser+=1
        if res[user][0]+res[user][4] > 0:
            uniqueuser+=1
            
        if len(txt)>absmaxchars-2*maxuserchars:
            restr+=res[user][0]
            restq+=res[user][4]
            continue
        count+=1
        txt="r_%s=%s q_%s=%s %s"%(count,res[user][0],count,res[user][4],txt)
    if (restr+restq) > 0:
        txt="r_rest=%s q_rest=%s %s"%(restr,restq,txt)

    header="show_jobs OK"
    summ="Running:%s Queued:%s"%(ans[0],ans[4])
    summary="R=%s Q=%s O=%s RN=%s RC=%s RP=%s QN=%s QC=%s QP=%s RU=%s QU=%s UU=%s"%(ans[0],ans[4],ans[8],ans[1],ans[2],int(ans[3]/3600),ans[5],ans[6],int(ans[7]/3600),runuser,queueuser,uniqueuser)
    ## too much chars for icinga/ido2db
    txt=''
    msg="%s - %s | %s %s"%(header,summ,summary,txt)

    print msg
    sys.exit(0)
else:
    print "%s running jobs on %s nodes (%s cores, %s prochours)"%(ans[0],ans[1],ans[2],int(ans[3]/3600))
    print "%s queued jobs for %s nodes (%s cores, %s prochours)"%(ans[4],ans[5],ans[6],int(ans[7]/3600))
    if ans[8] > 0:
        print "Other jobs: %s (%s)"%(ans[8],ans[9])

    if detailed:
        users=res.keys()
        users.sort()
        for user in users:
            print "  %s"%user
            print "    %s running jobs on %s nodes (%s cores, %s prochours)"%(res[user][0],res[user][1],res[user][2],int(res[user][3]/3600))
            print "    %s queued jobs for %s nodes (%s cores, %s prochours)"%(res[user][4],res[user][5],res[user][6],int(res[user][7]/3600))
            if res[user][8] > 0:
                print "    Other jobs: %s (%s)"%(res[user][8],res[user][9])

            
    sys.exit(0)

if nagios:
    print "show_jobs UNKNOWN"
    sys.exit(1)
